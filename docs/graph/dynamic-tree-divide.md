## 动态点分治

动态点分治用来解决 ** 带点权 / 边权修改 ** 的树上路径信息统计问题。

### 点分树

回顾点分治的计算过程。

对于一个结点 $x$ 来说，其子树中的简单路径包括两种：经过结点 $x$ 的，由一条或两条从 $x$ 出发的路径组成的；和不经过结点 $x$ 的，即已经包含在其所有儿子结点子树中的路径。

对于一个子树中简单路径的计算，我们选择一个分治中心 $rt$ ，计算经过该节点的子树中路径的信息，然后对于其每个儿子结点，将删去 $rt$ 后该点所在联通块作为一个子树，递归计算。选择的分治中心点可以构成一个树形结构，称为 ** 点分树 ** 。我们发现，计算点分树中同一层的结点所代表的联通块（即以该结点为分治中心的联通块）的大小总和是 $O(n)$ 的。这意味着，点分治的时间复杂度是与点分树的深度相关的，若点分树的深度为 $h$ ，则点分治的复杂度为 $O(nh)$ 。

可以证明，当我们每次选择联通块的重心作为分治中心的时候，点分树的深度最小，为 $O(\log_2 n)$ 的。这样，我们就可以在 $O(n\log_2 n)$ 的时间复杂度内统计树上 $O(n^2)$ 条路径的信息了。

由于树的形态在动态点分治的过程中不会改变，所以点分树的形态在动态点分治的过程中也不会改变。

下面给出求点分树的参考代码：

```cpp
void calcsiz(int x,int f)
{
    siz[x]=1;maxx[x]=0;
    for(int j=h[x];j;j=nxt[j])if(p[j]!=f&&!vis[p[j]])
    {
        calcsiz(p[j],x);
        siz[x]+=siz[p[j]];
        maxx[x]=max(maxx[x],siz[p[j]]);
    }
    maxx[x]=max(maxx[x],sum-siz[x]);// maxx[x] 表示以 x 为根时的最大子树大小
    if(maxx[x]<maxx[rt])rt=x;//这里不能写 <= ，保证在第二次 calcsiz 时 rt 不改变
}
void pre(int x)
{
    vis[x]=true;//表示在之后的过程中不考虑 x 这个点
    for(int j=h[x];j;j=nxt[j])if(!vis[p[j]])
    {
        sum=siz[p[j]];rt=0;maxx[rt]=inf;
        calcsiz(p[j],-1);calcsiz(rt,-1);//计算两次，第二次求出以 rt 为根时的各子树大小
        fa[rt]=x;pre(rt);//记录点分树上的父亲
    }
}
int main()
{
    sum=n;rt=0;maxx[rt]=inf;calcsiz(1,-1);calcsiz(rt,-1);
    pre(rt);
}
```

### 实现修改

在查询和修改的时候，我们在点分树上暴力跳父亲修改。由于点分树的深度最多是 $O(\log_2 n)$ 的，所以这样做复杂度能得到保证。

在动态点分治的过程中，需要一个结点到其点分树上的祖先的距离等其他信息，由于一个点最多有 $O(\log_2 n)$ 个祖先，我们可以在计算点分树时额外计算深度 ```dep[x]``` 或使用 LCA ，预处理出这些距离或实现实时查询。

在动态点分治的过程中，一个结点在其点分树上的祖先结点的信息中可能会被重复计算，这是我们需要消去重复部分的影响。一般的方法是对于一个联通块用两种方式记录：一个是其到分治中心的距离信息，另一个是其到点分树上分治中心父亲的距离信息。这一部分内容将在例题中得到展现。

??? note " 例题 [luogu P2056 \[ZJOI2007\]捉迷藏](https://www.luogu.org/problemnew/show/P2056)"

给定一棵有 $n$ 个结点的树，初始时所有结点都是黑色的。你需要实现一下两种操作：

 1. 反转一个结点的颜色（白变黑，黑变白）；
 
 2. 询问树上两个最远的黑点的距离。
 
 $n\le 10^5,m\le 5\times 10^5$
 
 
