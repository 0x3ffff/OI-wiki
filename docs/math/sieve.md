## 素数筛法

如果我们想要知道小于等于 n 有多少个素数呢？

一个自然的想法是我们对于小于等于 n 的每个数进行一次判定。这种暴力的做法显然不能达到最优复杂度，考虑如何优化呢。

考虑这样一件事情：如果 x 是合数，那么 x 的倍数也一定是合数。利用这个结论，我们可以避免很多次不必要的检测。

如果我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。

```c++
void genPrimes() {
  for (int i = 2; i <= n; ++i) {
    if (!vis[i]) pri[cnt++] = i;
    for (int j = 0; j < cnt; ++j) {
      if (i * pri[j] > n) break;
      vis[i * pri[j]] = 1;
      if (i % pri[j] == 0) break;
    }
  }
}
```

这个筛法被成为 eratosthenes （念作“埃拉托斯特尼”）筛法，时间复杂度是 $O(nloglogn)$。

以上做法仍有优化空间，我们发现这里面似乎会对某些数标记了很多次其为合数。有没有什么办法省掉无意义的步骤呢？

答案当然是：有！

每次标记倍数的时候不是对所有的倍数标记，而是去标记乘上之前的几个素数的结果。如果标记的过程中发现

## 筛法求欧拉函数

## 筛法求莫比乌斯函数

## 筛法求约数个数

## 其他线性函数

