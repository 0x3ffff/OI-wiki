\#线性时间的埃拉托色尼筛（Sieve of Eratosthenes Having Linear Time Complexity）

[TOC]

给定一个数字 $n$ ，找到范围 $[2,n]$ 中的所有质数。

解决任务的标准方法是使用 **Eratosthenes 筛法** 。该算法非常简单，但是它的时间复杂度为 $O(n \ log \ log n)$ 。

尽管有许多已知的具有次线性运行时间的算法（即 $O(n)$ ），但我们仍然要介绍一种非常有趣的算法。

给定算法的弱点是使用的内存比 **Eratosthenes 筛法** 更多：它需要一个大小为 $n$ 数组，而对于 **Eratosthenes 筛法** ，只需要 $n$ 位内存。

因此，仅对于数量小于等于 $10 ^ 7$ 的问题使用该算法是有意义的。

该算法的作者似乎属于 Gries&Misra[^er]。而且，严格来说，该算法不应被称为“Eratosthenes 筛”，因为它与经典算法有很大不同。

## 算法描述

我们的目的是计算范围 $[2,n]$ 每个数的最小质因数 $lp [i]$ 。

此外，我们需要存储所有找到的质数，称它为 $pr []$ 。

我们将用零初始化值 $lp [i]$ ，这意味着我们假设所有数字都是质数。在算法执行期间，该数组将逐渐填充。

现在，我们将遍历 $2$ 到 $n$ 的数字。对于当前数字 $i$ ，我们有两种情况：

如果 $lp [i] = 0$ ，那么这意味着 $i$ 是质数，令 $lp [i] = i$ 并将 $i$ 添加到列表 $pr []$ 的末尾。

如果 $lp [i] \neq 0$ ，则表示 $i$ 是合数的，其最小素数为 $lp [i]$ 。

在这两种情况下，我们都会为能被 $i$ 整除的数字更新 $lp []$ 的值。我们这样做是为了每个数字最多设置一次值 $lp []$ 。

考虑数字 $x_j = i \cdot p_j$ ，其中 $p_j$ 都是小于或等于 $lp [i]$ 的质数（这就是为什么我们需要存储所有质数的列表的原因）。并令 $lp [x_j] = p_j$ 。

该算法的正确性及其运行时间的证明放在实现之后。

## 实现

```cpp
const int N = 10000000;
int lp[N + 1];
vector<int> pr;

for (int i = 2; i <= N; ++i) {
  if (lp[i] == 0) {
    lp[i] = i;
    pr.push_back(i);
  }
  for (int j = 0; j < (int)pr.size() && pr[j] <= lp[i] && i * pr[j] <= N; ++j)
    lp[i * pr[j]] = pr[j];
}
```

我们可以通过用简单的数组和计数器替换 $pr$ 并省去 $for$ 循环中的乘法来加快速度（为此，我们只需要记录每一次的乘积即可）。

## 证明

我们需要证明该算法是正确的，以及 $lp []$ 里的每个值都将被设置一次。

显然，该算法将具有线性运行时间，时间复杂度为 $O(n)$ 。

请注意，每个数字 $i$ 的形式都只有一个表示形式：

 $i = lp [i] \cdot x$ ，

其中 $lp [i]$ 是 $i$ 的最小素数，而 $x$ 的素数不小于 $lp [i]$ ，即

 $lp [i] \le lp [x]$ 。

现在，回到算法：实际上，对于每个 $x$ ，它都会遍历所有小于或等于它的最小素数的素数，并与之相乘，即直到 $lp [x]$ 以内的所有素数，以获得上面给出的形式的数字。

因此，该算法将精确遍历每个合数一次，并赋予 $lp []$ 正确的值。

## 复杂度

即便该算法的时间复杂度 $O(n)$ 比原算法的时间复杂度 $O(n \log \log n)$ 要好，但是他们并没有特别大的差别。实际上，这只意味着两倍的速度差，优化版本的 **sieve** 运行速度和这里给出的算法基本上一样快。

考虑算法的空间复杂度：一个大小为 $n$ 的数组 $lp []$ , 和一个大小为 $\frac n {\ln n}$ 的数组 $pr []$ , 这个算法的空间复杂度显然比经典算法要差。

然而，它的可取之处在于，该算法计算了一个数组 $lp[]$ ，它允许我们找到 $[2, n]$ 任何数按大小顺序的因式分解。此外，使用一个额外的数组将允许我们在查找因数分解时避免重复查找。

能求出所有数字的因数分解对于某些任务是非常有用的，而且这个算法是少数允许在线性时间内找到它们的算法之一。

[^er]: David Gries, Jayadev Misra. A Linear Sieve Algorithm for Finding Prime Numbers[1978]
